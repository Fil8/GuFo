#!/usr/bin/env python3.6
'''

Set of tools for plotting moment 0,2,3 maps (flux distribution, velocity field, velocity dispersion maps) in different ways

Requirements
------------
Moment maps must exist. For optical observations can be generated by scavenger `momPlay()`
'''
import os, sys
from astropy.io import fits
import numpy as np

from lmfit import Model
from lmfit.models import GaussianModel
from lmfit.model import save_modelresult

from matplotlib import pyplot as plt
from matplotlib import rc
from matplotlib import gridspec
from matplotlib import patches as mpatches
from matplotlib import colorbar
from matplotlib.patches import Rectangle, Ellipse
from matplotlib import colors
from matplotlib.ticker import AutoMinorLocator, MultipleLocator, LogLocator, FormatStrFormatter, ScalarFormatter
from matplotlib import transforms as mtransforms
from matplotlib.ticker import LogFormatter 
from matplotlib.colors import LogNorm
from matplotlib.colors import SymLogNorm, Normalize
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.colors import ListedColormap
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

import matplotlib.cm as cm

from astropy import units as u
from astropy.coordinates import SkyCoord
from astropy.wcs import WCS
from astropy.nddata import Cutout2D
from reproject import reproject_interp, reproject_exact


from scavengers import cvPlay,tPlay
from scavengers import util as ut

cvP = cvPlay.convert()
tP = tPlay.tplay()

class MOMplot(object):
  '''This class draws moment 0,1,2 maps in different ways.

  '''

  def mom0Plot(self,cfg_par,imageName,lineName,lineNameStr,lineThresh,
    vRange=None,contourColors='black',nameFigLabel=None,overlayContours=False,
    contName=None,contLevels=None,contColors=None):
      
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = self.loadRcParams()
    plt.rcParams.update(params)


    hduIm = fits.open(imageName)[0]
    wcsIm = WCS(hduIm.header)

    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)
    
    fig = plt.figure()
    
    ax1 = plt.subplot(projection=wcsIm)    

    divider = make_axes_locatable(ax1)
    cax = divider.append_axes("right", size='2%', pad=0.1)
    if vRange == None:
      vRange=np.array([1,2],dtype=float)
      vRange[0] = lineThresh
      vRange[1] = np.nanmax(hduImCut.data)/5.

    img = ax1.imshow(hduImCut.data, cmap=cfg_par['moments']['colorMap'][0],vmin=vRange[0],vmax=vRange[1])

    colorTickLabels = np.linspace(vRange[0],vRange[1],9)    

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    cax.coords[0].grid(False)
    cax.coords[1].grid(False)
    cax.tick_params(direction='in')
    cax.coords[0].tick_params(top=False, bottom=False,
                   labeltop=False, labelbottom=False)
    cax.coords[1].set_ticklabel_position('r')
    cax.coords[1].set_axislabel(cfg_par['moments']['cBarLabel'][0])
    cax.coords[1].set_axislabel_position('r')
    cbar = plt.colorbar(img, cax=cax,ticks =colorTickLabels,
                    orientation='vertical', format='%d')   

    if lineNameStr=='Hb4861':
      lineNameStr=r'H$_\beta$4861'
    elif lineNameStr=='Ha6562':
      lineNameStr=r'H$_\alpha$6562'
    
    ax1.set_title(lineNameStr)

    ax1.set_autoscale_on(False)    
    #SaveOutput
    outMom = os.path.basename(imageName)
    outMom= str.split(outMom, '.fits')[0]  
    modName = cfg_par['gFit']['modName'] 

    if nameFigLabel==None:
        nameFigLabel='' 
    
    if overlayContours:
        imLevels =lineThresh*1.2*(np.arange(1,10,2))
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
        ax1.contour(hduImCut.data,levels=imLevels, colors=contourColors)
        nameFigLabel = nameFigLabel+'_cs'
    if contName:
      if nameFigLabel=='':
        nameFigLabel='over_'
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)

        ax1.contour(array.data,levels=contLevels[i], colors=contColors[i])
      

    outFig = cfg_par['general']['plotMomModDir']+outMom+nameFigLabel+'.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], bbox_inches = "tight",overwrite=True,dpi=300)#,
            #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)
    return 0

  def momAncPlot(self,cfg_par,imageName,Labels,CustomCmap,colorList,
  contourColors='black',nameFigLabel=None,overlayContours=False,
  contName=None,contLevels=None,contColors=None):

    hduIm = fits.open(imageName)[0]
    wcsIm = WCS(hduIm.header)

    #sn = resTable['SN_OIII5006']
    #idx  = np.where(sn<=lineThresh)

    #hduIm.data[idx] = np.nan 

    #sigmaThresh = sigmaTable['g1_SigIntr_OIII5006']
    #idx  = np.where(sigmaThresh>=cfg_par['moments']['sigmaThresh'])

    #hduIm.data[idx] = np.nan 
    
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = ut.loadRcParams()
    plt.rcParams.update(params)

    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)
    
    #idxLin = np.where(hduImCut==2.)
    #idxSey = np.where(hduImCut==1.)
    #idxKew = np.where(hduImCut==0.)
    #idxBad = np.where(hduImCut==-1.)        
    
    fig = plt.figure(figsize=(12,12),constrained_layout=False)
    fig.set_tight_layout(False)

    ax1 = plt.subplot(projection=hduImCut.wcs)    

    divider = make_axes_locatable(ax1)
    #cax = divider.append_axes("right", size='2%', pad=0.1)
    
    #if vRange == None:
    #  vRange=np.array([1,2])
    #  vRange[0] = lineThresh
    #  vRange[1] = np.nanmax(hduImCut.data)

    img = ax1.imshow(hduImCut.data, cmap=CustomCmap,interpolation='nearest')

    # get the colors of the values, according to the 
    # colormap used by imshow
    colours = [colors.to_rgba(colorList[i]) for i in range(0,len(Labels))]

    #colors = [img.cmap(img(value)) for value in values]
    #print(colors)
    # create a patch (proxy artist) for every color 
    patches = [ mpatches.Patch(color=colours[i],  label=Labels[i] ) for i in range(len(Labels)) ]
    # put those patched as legend-handles into the legend
    ax1.legend(handles=patches, loc=3, borderaxespad=0.)

    #cBarTicks = [-1,0,1,2]

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    #cax.coords[0].grid(False)
    #cax.coords[1].grid(False)
    #cax.tick_params(direction='in')
    #cax.coords[0].tick_params(top=False, bottom=False,
    #              labeltop=False, labelbottom=False)
    #cax.coords[1].set_ticklabel_position('r')
    #cax.coords[1].tick_params(top=False, bottom=False,
    #               labeltop=False, labelbottom=False)
    #cax.coords[1].set_axislabel('$\eta$-parameter')
    #cax.coords[1].set_axislabel_position('r')
    #cbar = plt.colorbar(img, cax=cax,ticks =cBarTicks,
    #               orientation='vertical', format='%d')   
    
    ax1.set_autoscale_on(False)    
    #SaveOutput
    outBPT = os.path.basename(imageName)
    outBPT= str.split(outBPT, '.fits')[0]  
    modName = cfg_par['gFit']['modName'] 

    if nameFigLabel==None:
        nameFigLabel='' 
    
    #if overlayContours:
    #    imLevels =[-0.5,0.5]
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
    #    ax1.contour(hduImCut.data,levels=imLevels, colors=contourColors)
    #    nameFigLabel = nameFigLabel+'_cs'
    if contName:
      if nameFigLabel=='':
        nameFigLabel='over_'
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)

        ax1.contour(array.data,levels=contLevels[i], colors=contColors[0])

    outFig = cfg_par['general']['plotMomModDir']+outBPT+nameFigLabel+'.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], bbox_inches = "tight",overwrite=True,dpi=300)#,
            #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)
    return 0

  def momAncPlotOver(self,cfg_par,imageName,secondImageName,thirdImageName,Labels,CustomCmapOne,CustomCmapThree,colorList,
  contourColors='black',nameFigLabel=None,overlayContours=False,
  contName=None,contLevels=None,contColors=None):

    hduIm = fits.open(imageName)[0]
    hduImTwo = fits.open(secondImageName)[0]
    hduImThree = fits.open(thirdImageName)[0]
    hduImData= np.array(hduIm.data,dtype='float64')
    hduImTwoData= np.array(hduIm.data,dtype='float64')
    hduImTwoData= np.array(hduIm.data,dtype='float64')

    wcsIm = WCS(hduIm.header)

    #sn = resTable['SN_OIII5006']
    #idx  = np.where(sn<=lineThresh)

    #hduIm.data[idx] = np.nan 

    #sigmaThresh = sigmaTable['g1_SigIntr_OIII5006']
    #idx  = np.where(sigmaThresh>=cfg_par['moments']['sigmaThresh'])

    #hduIm.data[idx] = np.nan 
    
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = self.loadRcParams()
    plt.rcParams.update(params)

    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)
    hduImTwoCut = Cutout2D(hduImTwo.data, centre, size, wcs=wcsIm)
    hduImThreeCut = Cutout2D(hduImThree.data, centre, size, wcs=wcsIm)

    #idxLin = np.where(hduImCut==2.)
    #idxSey = np.where(hduImCut==1.)
    #idxKew = np.where(hduImCut==0.)
    #idxBad = np.where(hduImCut==-1.)        
    
    fig = plt.figure()
    
    ax1 = plt.subplot(projection=wcsIm)    

    divider = make_axes_locatable(ax1)
    #cax = divider.append_axes("right", size='2%', pad=0.1)
    
    #if vRange == None:
    #  vRange=np.array([1,2])
    #  vRange[0] = lineThresh
    #  vRange[1] = np.nanmax(hduImCut.data)

    #CustomCmapOne.set_under(color='white')
    #ccaMap = cm.Greens_r
    #ccaMap.set_over(color='white')
    #CustomCmapThree.set_under(color='white')

    img = ax1.imshow(hduImCut.data, cmap=CustomCmapOne,alpha=1,interpolation='nearest')
    
    img2 = ax1.imshow(hduImTwoCut.data, cmap='YlGn_r',alpha=1,interpolation='nearest',vmin=-1e-1,vmax=1.1)
    img3 = ax1.imshow(hduImThreeCut.data, cmap=CustomCmapThree,alpha=1,interpolation='nearest')

    # get the colors of the values, according to the 
    # colormap used by imshow
    colours = [colors.to_rgba(colorList[i]) for i in range(0,len(Labels))]

    #colors = [img.cmap(img(value)) for value in values]
    #print(colors)
    # create a patch (proxy artist) for every color 
    patches = [ mpatches.Patch(color=colours[i],  label=Labels[i] ) for i in range(len(Labels)) ]
    # put those patched as legend-handles into the legend
    ax1.legend(handles=patches, loc=3, borderaxespad=0.)

    #cBarTicks = [-1,0,1,2]

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    #cax.coords[0].grid(False)
    #cax.coords[1].grid(False)
    #cax.tick_params(direction='in')
    #cax.coords[0].tick_params(top=False, bottom=False,
    #              labeltop=False, labelbottom=False)
    #cax.coords[1].set_ticklabel_position('r')
    #cax.coords[1].tick_params(top=False, bottom=False,
    #               labeltop=False, labelbottom=False)
    #cax.coords[1].set_axislabel('$\eta$-parameter')
    #cax.coords[1].set_axislabel_position('r')
    #cbar = plt.colorbar(img, cax=cax,ticks =cBarTicks,
    #               orientation='vertical', format='%d')   
    
    ax1.set_autoscale_on(False)    
    #SaveOutput
    outBPT = os.path.basename(imageName)
    outBPT= str.split(outBPT, '.fits')[0]  
    modName = cfg_par['gFit']['modName'] 

    if nameFigLabel==None:
        nameFigLabel='' 
    
    #if overlayContours:
    #    imLevels =[-0.5,0.5]
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
    #    ax1.contour(hduImCut.data,levels=imLevels, colors=contourColors)
    #    nameFigLabel = nameFigLabel+'_cs'
    if contName:
      if nameFigLabel=='':
        nameFigLabel='over_'
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)

        ax1.contour(array.data,levels=contLevels[i], colors=contColors[0])

    outFig = cfg_par['general']['plotMomModDir']+outBPT+nameFigLabel+'-shade.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], #bbox_inches = "tight",overwrite=True,dpi=100)#,
            dpi=300,bbox_inches='tight',transparent=False,overwrite=True)
    return 0


  def momAncPlotMultiple(self,cfg_par):

    tableNames = cfg_par['multipleRegions']['tableNames']
    regionNames = cfg_par['multipleRegions']['regions']

    colorNames = cfg_par['multipleRegions']['colors']
    
    momModDir = cfg_par['general']['momDir']+'multipleRegions'+'/'

    colorMaps = ListedColormap(colorNames[0])
    print(colorMaps)

    imageName=[]
    for i in range(0,len(tableNames)):

        imageName.append(momModDir+'mom-'+regionNames[i]+'.fits')
    

    # hduImTwoCut = Cutout2D(hduImTwo.data, centre, size, wcs=wcsIm)
    # hduImThreeCut = Cutout2D(hduImThree.data, centre, size, wcs=wcsIm)

    hduIm = fits.open(imageName[0])[0]
    wcsIm = WCS(hduIm.header)
    

    #sn = resTable['SN_OIII5006']
    #idx  = np.where(sn<=lineThresh)

    #hduIm.data[idx] = np.nan 

    #sigmaThresh = sigmaTable['g1_SigIntr_OIII5006']
    #idx  = np.where(sigmaThresh>=cfg_par['moments']['sigmaThresh'])

    #hduIm.data[idx] = np.nan 
    
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
    hduImCut1 = Cutout2D(hduIm.data, centre, size, wcs=wcsIm,mode='partial')

    params = ut.loadRcParams()
    plt.rcParams.update(params)


    #idxLin = np.where(hduImCut==2.)
    #idxSey = np.where(hduImCut==1.)
    #idxKew = np.where(hduImCut==0.)
    #idxBad = np.where(hduImCut==-1.)        
    
    fig = plt.figure(constrained_layout=False)
    fig.set_tight_layout(False)
    
    gs = plt.GridSpec(nrows=1, ncols=1,  figure=fig,wspace=0.0,hspace=0.0)
    ax1 = fig.add_subplot(gs[0,0],projection=hduImCut1.wcs)

    divider = make_axes_locatable(ax1)


    #cax = divider.append_axes("right", size='2%', pad=0.1)
    
    #if vRange == None:
    #  vRange=np.array([1,2])
    #  vRange[0] = lineThresh
    #  vRange[1] = np.nanmax(hduImCut.data)

    #CustomCmapOne.set_under(color='white')
    #ccaMap = cm.Greens_r
    #ccaMap.set_over(color='white')
    #CustomCmapThree.set_under(color='white'

    
    for i in range(0,len(imageName)):
        colorMaps = ListedColormap(colorNames[i])

        hduIm = fits.open(imageName[i])[0]
        wcsImm = WCS(hduIm.header)
        hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsImm,mode='partial')

        img = ax1.imshow(hduImCut.data, cmap=colorMaps,alpha=1,interpolation='nearest',vmin=-1e-1,vmax=1.1)
    
    # get the colors of the values, according to the 
    # colormap used by imshow

    #colors = [img.cmap(img(value)) for value in values]
    #print(colors)
    # create a patch (proxy artist) for every color 
    patches = [ mpatches.Patch(color=colorNames[i],  label=regionNames[i] ) for i in range(len(regionNames)) ]
    # put those patched as legend-handles into the legend
 
    # ax1.legend = plt.legend(handles=patches, loc=3, borderaxespad=0.,prop={'size': 18})
    # for lh in ax1.legend.legendHandles: 
    #     lh.set_alpha(1)        
    #     #lh.set_sizes([50.0])
    #     #lh._legmarker.set_markersize(18)
    # ax1.legend.get_frame().set_edgecolor('black')
    # ax1.legend.get_frame().set_facecolor('white')
    #cBarTicks = [-1,0,1,2]

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    #cax.coords[0].grid(False)
    #cax.coords[1].grid(False)
    #cax.tick_params(direction='in')
    #cax.coords[0].tick_params(top=False, bottom=False,
    #              labeltop=False, labelbottom=False)
    #cax.coords[1].set_ticklabel_position('r')
    #cax.coords[1].tick_params(top=False, bottom=False,
    #               labeltop=False, labelbottom=False)
    #cax.coords[1].set_axislabel('$\eta$-parameter')
    #cax.coords[1].set_axislabel_position('r')
    #cbar = plt.colorbar(img, cax=cax,ticks =cBarTicks,
    #               orientation='vertical', format='%d')   
    
    #SaveOutput

    
    #if overlayContours:
    #    imLevels =[-0.5,0.5]
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
    #    ax1.contour(hduImCut.data,levels=imLevels, colors=contourColors)
    #    nameFigLabel = nameFigLabel+'_cs'
    if cfg_par['multipleRegions']['contOver'] == True:
        contName=cfg_par['multipleRegions']['contName']
        contLevels=cfg_par['multipleRegions']['contLevels']
        hduCont = fits.open(contName)[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont,mode='partial')    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)

        ax1.contour(array.data,levels=contLevels, colors='gray',linewidths=2.)

    outFigDir = momModDir+'plots/'
    if not os.path.exists(outFigDir):
            os.mkdir(outFigDir)
    outFig = outFigDir +'KMultipleMom'+cfg_par['multipleRegions']['Name']+'.'+cfg_par['moments']['plotFormat']

    ax1.set_autoscale_on(False)    

    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], #bbox_inches = "tight",overwrite=True,dpi=100)#,
            dpi=300,bbox_inches='tight',transparent=False,overwrite=True)
    return 0

  def momPlot(self,cfg_par,im1,imMom0=None,
    cRange=None,imLevels=None,imContColors=['black','black'],beamCoords=None,
    contName=None,contValues=None,contColors=None,interpolation=None,title=False,
    colorBar=False,shareScale=True,kind='mom1'):
    '''Draws one moment map

    Parameters
    ----------

    cfg_par: OrderedDictionary
        Dictionary with alla parameters or gufo. 
        Parameters are given from terminal, or in a `.yml' file.

    im1: str
        full path to first moment map

    inMom0: str, optional
        _default=None_, alternative moment map for overplotting contours 
        (for example mom0 contours over mom1 map)

    cRange: np.array, optional
        [2,2] array with the min max range of the two colorscales

    imLevels: np.array, optional
        [2,N] array with N contours to plot (referring to im1, im2 or imMom0, if given)

    imContColors: list, optional
        _default=['black','black']_ color of contours

    beamCoords: np.array, optional
        [2,2] array. If given the PSF of the observations is plotted at the coordinates.
        PSF axes and PA are taken from the header of the moments or from cfg_par['genaral']['psf']
    
    contName: str, optional
        full path to continuum image for which overlay the contours

    contValues: np.array, optional
        [N] array with N contours of the continuum image to overlay

    contColors: list, optional
        list with colors of continuum contours

    interpolation: str, optional
        kind of interpolation for `matplotlib.imshow`

    title: list, optional
        title of plot

    shareScale: bool, optional
        _default=True_: moment maps are plotted over the same colorScale

    colorBar: bool, optional
        _default=True_: plot or not the colorbar

    kind: str
        _default='mom1'_: kind of moment to plot (mom0, mom1, mom2, h2h1)

    Returns
    ----------
    outFig: str
        full path to output figure

    Notes
    ----------
    Useful for plotting moment maps of different phases of the gas.

    '''


    
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = ut.loadRcParams()
    plt.rcParams.update(params)


    hduIm1 = fits.open(im1)[0]
    wcsIm1 = WCS(hduIm1.header)
    hduImCut1 = Cutout2D(hduIm1.data, centre, size, wcs=wcsIm1)


    fig = plt.figure(constrained_layout=False)
    fig.set_tight_layout(False)

    gs = plt.GridSpec(nrows=1, ncols=1,  figure=fig,wspace=0.0,hspace=0.0)
    
    ax1 = fig.add_subplot(gs[0,0],projection=hduImCut1.wcs)
    

    if not isinstance(cRange,np.ndarray):
        vRange=np.array([2])
        vRange[0] = np.nanmin(hduImCut1.data)
        vRange[1] = np.nanmax(hduImCut1.data)
    else:
        vRange=cRange
    
    if kind == 'mom0':
        cMap = cfg_par['moments']['colorMap'][0]
        dd = np.array(hduImCut1.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduImCut1.data= dd
    elif kind =='h2h1':
        cMap = cfg_par['moments']['colorMap'][0]
        if imMom0 is not None:
            hduImMom0 = fits.open(imMom0)[0]
            wcshduImMom0 = WCS(hduImMom0.header)
            hduImMom0Cut = Cutout2D(hduImMom0.data, centre, size, wcs=wcshduImMom0)
    else:
        cMap = 'jet'
    current_cmap = cm.get_cmap(cMap)
    
    current_cmap.set_bad(color='white')


    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    img = ax1.imshow(hduImCut1.data, cmap=cMap,vmin=vRange[0]-0.5,vmax=vRange[1]+0.5,
        interpolation=interpolation)

    if title==True:
        ax1.set_title(cfg_par['moments']['line'][0])

    ax1.set_autoscale_on(False)    
    if 'BMAJ' in hduIm1.header and beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        el = Ellipse((xbeam, ybeam), hduIm1.header['BMAJ'], hduIm1.header['BMIN'],
                 angle=hduIm1.header['BMAJ'], linewidth=2, fill=False, zorder=2,transform=ax1.get_transform('fk5'))
        ax1.add_patch(el)           

    if isinstance(imLevels,np.ndarray) and kind=='mom0':

        cs = ax1.contour(hduImCut1.data,levels=imLevels[0,:], colors=imContColors[0])

    elif isinstance(imLevels,np.ndarray) and kind=='h2h1':
        if imMom0 is not None:
            hduMom0 = fits.open(imMom0)[0]
            wcsMom0 = WCS(hduMom0.header)
            hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0)    
            array, footprint = reproject_interp((hduMom0Cut.data, hduMom0Cut.wcs) ,
                                                hduImCut1.wcs, shape_out=hduImCut1.shape)

            cs = ax1.contour(array.data,levels=imLevels[0,:], colors=imContColors[0])
            cs = ax1.contour(array.data,levels=imLevels[1,:], colors=imContColors[1],linestyles = 'dashed',linewidths=2)
        else:
            cs = ax1.contour(hduImCut1.data,levels=imLevels[0,:], colors=imContColors[0])
            cs = ax1.contour(hduImCut1.data,levels=imLevels[1,:], colors=imContColors[1],linestyles = 'dashed',linewidths=2)

    elif isinstance(imLevels,np.ndarray) and kind!='mom0' and imMom0 is not None:
        hduMom0 = fits.open(imMom0[0])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0)
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax1.contour(hduMom0Cut.data,levels=imLevels[0,:], colors=imContColors[0])

    if contName:

      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut1.wcs, shape_out=hduImCut1.shape)

        cs = ax1.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax1.clabel(cs, inline=1, fontsize=14)

    if colorBar==True:
        colorTickLabels = cfg_par['moments']['colorTickLabels'][0]
        mom1BarLabel=cfg_par['moments']['cBarLabel']

        axins = inset_axes(ax1,
                       width="5%",  # width = 5% of parent_bbox width
                       height="100%",  # height : 50%
                       loc='lower left',
                       bbox_to_anchor=(1.05, 0., 1, 1),
                       bbox_transform=ax1.transAxes,
                       borderpad=0,
                       )


        cbar = fig.colorbar(img, cax=axins,ticks =colorTickLabels,
                      orientation='vertical', format='%d')   
        cbar.set_label(mom1BarLabel, rotation=-90, va="bottom")

    #SaveOutput
    fig.subplots_adjust(hspace=0.,wspace=0.)

    if kind=='h2h1':
        if contName and colorBar==False:
            outFig= cfg_par['general']['plotMomModDir']+kind+'_overCont.'+cfg_par['moments']['plotFormat']
        elif contName and colorBar==True:
            outFig= cfg_par['general']['plotMomModDir']+kind+'_overContCb.'+cfg_par['moments']['plotFormat']
        else:
            outFig= cfg_par['general']['plotMomModDir']+kind+'.'+cfg_par['moments']['plotFormat']

    else:
        if contName:
            outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['line'][0]+'_overCont.'+cfg_par['moments']['plotFormat']
        else:
            outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['line'][0]+'.'+cfg_par['moments']['plotFormat']
    
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'],bbox_inches = "tight", dpi=300,transparent=False,overwrite=True)#,
    
    plt.show()
    plt.close()

    return outFig


  def momPlotDoublet(self,cfg_par,im1,im2,imMom0=None,
    cRange=None,imLevels=None,imContColors=['black','black'],beamCoords=None,
    contName=None,contValues=None,contColors=None,interpolation=None,title=False,
    shareScale=True,kind='mom1'):
    '''Draws two moment maps on the same row. 

    Parameters
    ----------

    cfg_par: OrderedDictionary
        Dictionary with alla parameters or gufo. 
        Parameters are given from terminal, or in a `.yml' file.

    im1: str
        full path to first moment map

    im2: str
        full path to second moment map

    inMom0: str, optional
        _default=None_, alternative moment map for overplotting contours 
        (for example mom0 contours over mom1 map)

    cRange: np.array, optional
        [2,2] array with the min max range of the two colorscales

    imLevels: np.array, optional
        [2,N] array with N contours to plot (referring to im1, im2 or imMom0, if given)

    imContColors: list, optional
        _default=['black','black']_ color of contours

    beamCoords: np.array, optional
        [2,2] array. If given the PSF of the observations is plotted at the coordinates.
        PSF axes and PA are taken from the header of the moments or from cfg_par['genaral']['psf']
    
    contName: str, optional
        full path to continuum image for which overlay the contours

    contValues: np.array, optional
        [N] array with N contours of the continuum image to overlay

    contColors: list, optional
        list with colors of continuum contours

    interpolation: str, optional
        kind of interpolation for `matplotlib.imshow`

    title: list, optional
        2Nlist with title of subplots

    shareScale: bool, optional
        _default=True_: moment maps are plotted over the same colorScale

    kind: str
        _default='mom1'_: kind of moment to plot (mom0, mom1, mom2)

    Returns
    ----------
    outFig: str
        full path to output figure

    Notes
    ----------
    Useful for plotting moment maps of different phases of the gas.

    '''
    
    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = ut.loadRcParams()
    plt.rcParams.update(params)


    hduIm1 = fits.open(im1)[0]
    wcsIm1 = WCS(hduIm1.header)
    hduImCut1 = Cutout2D(hduIm1.data, centre, size, wcs=wcsIm1)

    hduIm2 = fits.open(im2)[0]
    wcsIm2 = WCS(hduIm2.header)
    hduImCut2 = Cutout2D(hduIm2.data, centre, size, wcs=wcsIm2)


    fig = plt.figure(figsize =(12,10), constrained_layout=False)
    fig.set_tight_layout(False)
    if shareScale==False:
        gs = plt.GridSpec(nrows=1, ncols=2,  figure=fig,wspace=0.25,hspace=0.0)
    else:
        gs = plt.GridSpec(nrows=1, ncols=2,  figure=fig,wspace=0.0,hspace=0.0)
    
    ax1 = fig.add_subplot(gs[0,0],projection=hduImCut1.wcs)
    

    if not isinstance(cRange,np.ndarray):
        vRange=np.array([2,2])
        vRange[0,0] = np.nanmin(hduImCut1.data)
        vRange[0,1] = np.nanmax(hduImCut1.data)
        vRange[1,0] = np.nanmin(hduImCut2.data)
        vRange[1,1] = np.nanmax(hduImCut2.data)
    else:
        vRange=cRange
    if kind == 'mom0':
        cMap = cfg_par['moments']['colorMap'][0]
        dd = np.array(hduImCut1.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduImCut1.data= dd
    else:
        cMap = 'jet'

    current_cmap = cm.get_cmap(cMap)
    
    current_cmap.set_bad(color='white')


    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    img = ax1.imshow(hduImCut1.data, cmap=cMap,vmin=vRange[0,0]-0.5,vmax=vRange[0,1]+0.5,
        interpolation=interpolation)

    if title==True:
        ax1.set_title(cfg_par['moments']['line'][0])

    ax1.set_autoscale_on(False)    
    if 'BMAJ' in hduIm1.header and beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        el = Ellipse((xbeam, ybeam), hduIm1.header['BMAJ'], hduIm1.header['BMIN'],
                 angle=hduIm1.header['BMAJ'], linewidth=2, fill=False, zorder=2,transform=ax1.get_transform('fk5'))
        ax1.add_patch(el)           

    if isinstance(imLevels,np.ndarray) and kind=='mom0':

        cs = ax1.contour(hduImCut1.data,levels=imLevels[0,:], colors=imContColors[0])

    elif isinstance(imLevels,np.ndarray) and kind!='mom0' and imMom0 is not None:
        hduMom0 = fits.open(imMom0[0])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0)
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax1.contour(hduMom0Cut.data,levels=imLevels[0,:], colors=imContColors[0])

    if contName:

      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut1.wcs, shape_out=hduImCut1.shape)

        cs = ax1.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax1.clabel(cs, inline=1, fontsize=14)

    if shareScale == False:

        colorTickLabels = cfg_par['moments']['colorTickLabels'][0]
        mom1BarLabel=cfg_par['moments']['cBarLabel']

        axins = inset_axes(ax1,
                       width="5%",  # width = 5% of parent_bbox width
                       height="100%",  # height : 50%
                       loc='lower left',
                       bbox_to_anchor=(1.05, 0., 1, 1),
                       bbox_transform=ax1.transAxes,
                       borderpad=0,
                       )


        cbar = fig.colorbar(img, cax=axins,ticks =colorTickLabels,
                      orientation='vertical', format='%d')   
        cbar.set_label(mom1BarLabel, rotation=-90, va="bottom")
 

    ax2 = fig.add_subplot(gs[0,1],projection=hduImCut2.wcs)


 
    if kind == 'mom0' and shareScale==False:
        dd = np.array(hduImCut2.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduImCut2.data= dd
        cMap = cfg_par['moments']['colorMap'][1]
    elif kind == 'mom0' and shareScale==True:
        cMap = cfg_par['moments']['colorMap'][0]
    else:
        cMap = 'jet'
    
    img = ax2.imshow(hduImCut2.data, cmap=cMap,vmin=vRange[1,0]-0.5,vmax=vRange[1,1]+0.5,
        interpolation=interpolation)

    ax2.coords[1].set_axislabel(r'Dec (J2000)')
    ax2.coords[1].set_ticklabel_visible(False)
    ax2.coords[0].set_axislabel(r'RA (J2000)')


    if title==True:
        ax2.set_title(cfg_par['moments']['line'][1])
    if isinstance(imLevels,np.ndarray) and kind=='mom0':
        cs = ax2.contour(hduImCut2.data,levels=imLevels[1,:], colors=imContColors[1])
    elif isinstance(imLevels,np.ndarray) and kind!='mom0' and (imMom0 is not None):
        hduMom0 = fits.open(imMom0[1])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0)
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax2.contour(hduMom0Cut.data,levels=imLevels[1,:], colors=imContColors[1])

    ax2.set_autoscale_on(False)    
    if 'BMAJ' in hduIm2.header and beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        el = Ellipse((xbeam, ybeam), hduIm2.header['BMAJ'], hduIm2.header['BMIN'],
                 angle=hduIm2.header['BMAJ'], linewidth=2, fill=False, zorder=2,transform=ax2.get_transform('fk5'))
        ax2.add_patch(el)        

    if contName:
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut2.wcs, shape_out=hduImCut2.shape)

        cs = ax2.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax2.clabel(cs, inline=1, fontsize=14)
  
    if kind == 'mom0':
        mom1BarLabel=cfg_par['moments']['cBarLabel']
        colorTickLabels = cfg_par['moments']['colorTickLabels'][1]

    elif kind=='mom1':
        mom1BarLabel=r'$v_{\rm los}-v_{\rm sys}$ [km s$^{-1}$]'
        colorTickLabels = np.linspace(vRange[1,0],vRange[1,1],5)  

    elif kind=='mom2':
        mom1BarLabel=r'$\sigma_{\rm los}$ [km s$^{-1}$]'
        colorTickLabels = np.arange(vRange[1,0],vRange[1,1]+50.,50.)    

    axins = inset_axes(ax2,
                   width="5%",  # width = 5% of parent_bbox width
                   height="100%",  # height : 50%
                   loc='lower left',
                   bbox_to_anchor=(1.05, 0., 1, 1),
                   bbox_transform=ax2.transAxes,
                   borderpad=0,
                   )

    cbar = fig.colorbar(img, cax=axins,ticks =colorTickLabels,
                  orientation='vertical', format='%d')   
    cbar.set_label(mom1BarLabel, rotation=-90, va="bottom")
 
    #SaveOutput
    fig.subplots_adjust(hspace=0.,wspace=0.)
    if contName:
        outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['line'][0]+cfg_par['moments']['line'][1]+'_overCont.'+cfg_par['moments']['plotFormat']
    else:
        outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['line'][0]+cfg_par['moments']['line'][1]+'.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'],bbox_inches = "tight", dpi=300,transparent=False,overwrite=True)#,
    plt.show()
    print(outFig)
    plt.close()

    return outFig


  def mom2Plot(self,cfg_par,imageName,lineName,lineThresh,lineNameStr,keyword,vRange=None,
    modName='g1',contourColors='black',nameFigLabel=None,overlayContours=False,
    contName=None,contValues=None,contColors=None,interpolation=None):

    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = ut.loadRcParams()
    plt.rcParams.update(params)

    #mom0Map = fits.open(cfg_par['general']['momModDir']+'mom0_'+modName+'-'+lineName+'.fits')
    #hBetaData = mom0Map[0].data

    hduIm = fits.open(imageName)[0]
    wcsIm = WCS(hduIm.header)

    #idx = np.where(np.isnan(hBetaData))
    #hduIm.data[idx] = np.nan


    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)
    
    fig = plt.figure()
    
    ax1 = plt.subplot(projection=wcsIm)    

    divider = make_axes_locatable(ax1)
    cax = divider.append_axes("right", size='2%', pad=0.1)
  
    #vRange=np.array([1,2])
    #vRange[0] = np.nanmin(hduImCut.data)
    #vRange[1] = np.nanmax(hduImCut.data)

    if len(cfg_par[keyword]['cBarLabel'])>1:
      mom1BarLabel=r'[km s$^{-1}$]'
      cMap = plt.cm.jet
    else:
      mom1BarLabel = r+str(cfg_par[keyword]['cBarLabel'][2])
      cMap = plt.cm.cfg_par[keyword]['colorMap'][2]

    if cfg_par[keyword]['cBarLabel'][0].split(' ',maxsplit=2)[0]=='w80':
        mom1BarLabel=r'$w80$ [km s$^{-1}$]'
        cMap = plt.cm.Reds
        cMap.set_under(color='grey')

#    img = ax1.imshow(hduImCut.data, cmap=cMap,vmin=vRange[0]-0.5,vmax=vRange[1]+0.5)
    img = ax1.imshow(hduImCut.data, cmap=cMap,vmin=vRange[0],vmax=vRange[1],
        interpolation=interpolation)

    colorTickLabels = np.arange(vRange[0],vRange[1]+100,100)    

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    ax1.coords[1].set_major_formatter('dd:mm:ss')
    ax1.coords[0].set_major_formatter('hh:mm:ss')

    
    cax.coords[0].grid(False)
    cax.coords[1].grid(False)
    cax.tick_params(direction='in')
    cax.coords[0].tick_params(top=False, bottom=False,
                   labeltop=False, labelbottom=False)
    cax.coords[1].set_ticklabel_position('r')

    cax.coords[1].set_axislabel(mom1BarLabel)
    cax.coords[1].set_axislabel_position('r')
    cax.coords[1].set_ticklabel_visible(True)     

    cbar = plt.colorbar(img, cax=cax,ticks =colorTickLabels,
                    orientation='vertical', format='%d')   
    
    if lineNameStr=='Hb4861':
      lineNameStr=r'H$_\beta$4861'
    elif lineNameStr=='Ha6562':
      lineNameStr=r'H$_\alpha$6562'

    #ax1.set_title(lineNameStr)

    ax1.set_autoscale_on(False)    
    #SaveOutput
    outMom = os.path.basename(imageName)
    outMom= str.split(outMom, '.fits')[0]  
    modName = cfg_par['gFit']['modName'] 

    if nameFigLabel==None:
        nameFigLabel='' 
    if overlayContours:
        imLevels =lineThresh*1.2*(np.arange(1,10,2))
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
        cs = ax1.contour(hduImCut.data,levels=imLevels, colors=contourColors)
        nameFigLabel = nameFigLabel+'_cs'
        if contValues[0]==1:
            ax1.clabel(cs, inline=1, fontsize=14)

    if contName:
      if nameFigLabel=='':
        nameFigLabel='over_'
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)

        cs = ax1.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax1.clabel(cs, inline=1, fontsize=14)

    outFig = cfg_par['general']['plotMomModDir']+outMom+nameFigLabel+'.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], bbox_inches = "tight",overwrite=True,dpi=300,transparent=False)#,
            #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)

    plt.close()
    return 0

  def momTriplet(self,cfg_par,im1,im2,im3,inMom0=None,
    cRange=None,imLevels=None,imContColors=['black','black','black'],beamCoords=None,
    contName=None,contValues=None,contColors=None,interpolation=None,title=False,
    shareScale=True,kind='mom1', momunit='m/s'):
    '''Draws three moment maps on the same row. 

    Parameters
    ----------

    cfg_par: OrderedDictionary
        Dictionary with alla parameters or gufo. 
        Parameters are given from terminal, or in a `.yml' file.

    im1: str
        full path to first moment map

    im2: str
        full path to second moment map

    im3: str
        full path to second moment map

    inMom0: str, optional
        _default=None_, alternative moment map for overplotting contours 
        (for example mom0 contours over mom1 map)

    cRange: np.array, optional
        [2,2] array with the min max range of the two colorscales

    imLevels: np.array, optional
        [2,N] array with N contours to plot (referring to im1, im2 or imMom0, if given)

    imContColors: list, optional
        _default=['black','black','black']_ color of contours

    beamCoords: np.array, optional
        [3,2] array. If given the PSF of the observations is plotted at the coordinates.
        PSF axes and PA are taken from the header of the moments or from cfg_par['genaral']['psf']
    
    contName: str, optional
        full path to continuum image for which overlay the contours

    contValues: np.array, optional
        [N] array with N contours of the continuum image to overlay

    contColors: list, optional
        list with colors of continuum contours

    interpolation: str, optional
        kind of interpolation for `matplotlib.imshow`

    title: list, optional
        2Nlist with title of subplots

    shareScale: bool, optional
        _default=True_: moment maps are plotted over the same colorScale

    kind: str
        _default='mom1'_: kind of moment to plot (mom0, mom1, mom2)

    momunit: str
        _default='m/s': specify unit of mom1,2 maps (m/s or km/s)

    Returns
    ----------
    outFig: str
        full path to output figure

    Notes
    ----------
    Useful for : moment maps of multiple gaussian components
        moment maps of observations at different resolutions.
    
    '''


    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlotY'],cfg_par['moments']['sizePlotX']), u.arcmin)

    print('cio')
    params = ut.loadRcParams()
    plt.rcParams.update(params)

    hduIm1 = fits.open(im1)[0]
    wcsIm1 = WCS(hduIm1.header)

    #centre = SkyCoord(ra=hduIm1.header['CRVAL1']*u.degree, dec=hduIm1.header['CRVAL2']*u.degree, frame='fk5')
    #size = u.Quantity((20 ,15), u.arcmin)

    # hduImCut1 = Cutout2D(hduIm1.data, (hduIm1.header['NAXIS1']/2,hduIm1.header['NAXIS2']/2), size, wcs=wcsIm1,
    #     mode='partial')

    hduImCut1 = Cutout2D(hduIm1.data, centre, size, wcs=wcsIm1,
        mode='partial')
    #centre = SkyCoord(ra=hduIm1.header['CRVAL1']*u.degree, dec=hduIm1.header['CRVAL2']*u.degree, frame='fk5')

    #size = u.Quantity((16.6 ,12.1), u.arcmin)

    hduIm2 = fits.open(im2)[0]
    wcsIm2 = WCS(hduIm2.header)
    # hduImCut2 = Cutout2D(hduIm2.data, (hduIm2.header['NAXIS1']/2,hduIm2.header['NAXIS2']/2), size, wcs=wcsIm2,
    #     mode='partial')

    hduImCut2 = Cutout2D(hduIm2.data, centre, size, wcs=wcsIm2,
        mode='partial')

    hduIm3 = fits.open(im3)[0]
    wcsIm3 = WCS(hduIm3.header)
    #centre = SkyCoord(ra=hduIm1.header['CRVAL1']*u.degree, dec=hduIm1.header['CRVAL2']*u.degree, frame='fk5')

    #size = u.Quantity((15,15), u.arcmin)
    #size = u.Quantity((20 ,15), u.arcmin)
    hduImCut3 = Cutout2D(hduIm3.data, centre, size, wcs=wcsIm3,
        mode='partial')
    # hduImCut3 = Cutout2D(hduIm3.data, (hduIm3.header['NAXIS1']/2,hduIm3.header['NAXIS2']/2), size, wcs=wcsIm3,
    #     mode='partial')

    fig = plt.figure(figsize =(12,10), constrained_layout=False)
    fig.set_tight_layout(False)
    
    gs = plt.GridSpec(nrows=1, ncols=3,  figure=fig,wspace=0.0,hspace=0.0)

    ax1 = fig.add_subplot(gs[0,0],projection=hduImCut1.wcs)

    if not isinstance(cRange,np.ndarray) and kind!='electronDensity' and kind!='dustExtinction':
        vRange=np.array([1,2])
        vRange[0] = np.nanmin(hduImCut1.data)
        vRange[1] = np.nanmax(hduImCut1.data)
        print('cazzo')
    elif isinstance(cRange,np.ndarray) and kind!='electronDensity'and kind!='dustExtinction':
        vRange=cRange
        print('culo')
        print(vRange)
    elif not isinstance(cRange,np.ndarray) and kind=='electronDensity':
        print('figa')

        vRange=np.array([1,2])
        vRange[0] = np.log10(40.)
        vRange[1] = np.log10(1e4)

    elif not isinstance(cRange,np.ndarray) and kind=='dustExtinction':
        print('cullo')

        vRange=np.array([1,2])
        vRange[0] = 1
        vRange[1] =5



    if kind == 'mom0':
        cMap = cfg_par['moments']['colorMap'][0]
        dd1 = np.array(hduImCut1.data,dtype=float)
        index=np.where(dd1==0.)
        dd1[index] = np.nan
        hduImCut1.data= dd1
        dd2 = np.array(hduImCut2.data,dtype=float)
        index=np.where(dd2==0.)
        dd2[index] = np.nan
        hduImCut2.data= dd2
        dd3 = np.array(hduImCut3.data,dtype=float)
        index=np.where(dd3==0.)
        dd3[index] = np.nan
        hduImCut3.data= dd3

    elif kind=='mom1' :
        cMap = 'jet'
        if momunit=='m/s':
            cMap='RdBu_r'
            cmap = plt.cm.jet  # define the colormap
            # extract all colors from the .jet map
            cmaplist = [cmap(i) for i in range(cmap.N)]
            # force the first color entry to be grey
            #cmaplist[0] = (.5, .5, .5, 1.0)

            # create the new map
            cmap = colors.LinearSegmentedColormap.from_list(
                'Custom cmap', cmaplist, cmap.N)

            # define the bins and normalize
            bounds = np.linspace(vRange[0],vRange[1], 25)
            norm = colors.BoundaryNorm(bounds, cmap.N)
            hduImCut1.data /=1e3
            hduImCut2.data /=1e3
            hduImCut3.data /=1e3
    elif kind=='mom2' :
        cMap = 'jet'
        if momunit=='m/s':
            #cMap='Reds'
            hduImCut1.data /=1e3
            hduImCut2.data /=1e3
            hduImCut3.data /=1e3



    elif kind =='electronDensity':
        #dd1 = np.array(hduImCut1.data,dtype=float)
        #indexMin1=np.where(dd1<=0.)
        #indexMax1=np.where(dd1>=9.)
        #dd1[indexMin1] = 0.0
        #dd1[indexMax1] = 0.0

        #hduImCut1.data= dd1

        #dd2 = np.array(hduImCut2.data,dtype=float)
        #indexMin2=np.where(dd2<=0.)
        #indexMax2=np.where(dd2>=20.)
        #dd2[indexMin2] = 0.0
        #dd2[indexMax2] = 0.0
        #hduImCut2.data= dd2

        #dd3 = np.array(hduImCut3.data,dtype=float)
        #indexMin3=np.where(dd3<=0.)
        #indexMax3=np.where(dd3>=9.)
        #dd3[indexMin3] = 0.0
        #dd3[indexMax3] = 0.0
        #hduImCut3.data= dd3


        cMap = 'RdPu'
    elif kind=='dustExtinction':
        cMap = 'PuRd_r'

    c = SkyCoord('00:00:30.0','00:05:00.0',unit=(u.hourangle,u.deg))
    ax1.coords[0].set_ticks(spacing=c.ra.degree*u.degree)
    ax1.coords[1].set_ticks(spacing=c.dec.degree*u.degree)

    ax1.coords[1].set_axislabel(r'Dec (J2000)')

    ax1.coords[0].set_axislabel(r'RA (J2000)')

    img = ax1.imshow(hduImCut1.data, cmap=cMap,norm=norm,vmin=vRange[0],vmax=vRange[1],
        interpolation=interpolation)

    if (isinstance(imLevels,np.ndarray) and kind=='mom0' and inMom0 is None):
        cs = ax1.contour(hduImCut1.data,levels=imLevels[0,:], colors=imContColors[0],lw=0.4)
    elif isinstance(imLevels,np.ndarray) and inMom0 is not None:
        hduMom0 = fits.open(inMom0[0])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0,mode='partial')
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax1.contour(hduMom0Cut.data,levels=imLevels[0,:], colors=imContColors[0],lw=0.4)

    # if kind == 'mom2' or kind == None:
    #     colorTickLabels = np.arange(vRange[0],vRange[1]+100.,100.)    
    # elif kind == 'mom1':
    #     colorTickLabels = np.linspace(vRange[0],vRange[1],5)  
    # elif kind == 'mom0':
    #     if 'colorTickLabels' in cfg_par['moments']:
    #         colorTickLabels = cfg_par['moments']['colorTickLabels'][0]
    #     else:
    #         colorTickLabels = np.linspace(vRange[0],vRange[1]+100,8)    
    # else:
    #     colorTickLabels = np.arange(vRange[0],vRange[1]+100.,100.)    

    if title==True:
        ax1.set_title(cfg_par['moments']['title'][0])

    ax1.set_autoscale_on(False)    

    if beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        if 'BMAJ' in hduIm1.header:
            ellX = hduIm1.header['BMAJ']
            ellY = hduIm1.header['BMIN']
            ellPA = hduIm1.header['BPA']
        else:
            ellX = cfg_par['general']['psf'][0]/3600.
            ellY = cfg_par['general']['psf'][1]/3600.
            ellPA = cfg_par['general']['psf'][2]

        el = Ellipse((xbeam, ybeam), ellX, ellY,
                 angle=ellPA, linewidth=1, fill=False, zorder=2,transform=ax1.get_transform('fk5'))
        ax1.add_patch(el)  


    modName = cfg_par['gFit']['modName'] 
    if contName:
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut1.wcs, shape_out=hduImCut1.shape)

        cs = ax1.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax1.clabel(cs, inline=1, fontsize=14)

    ax2 = fig.add_subplot(gs[0,1],projection=hduImCut2.wcs)
    
    img = ax2.imshow(hduImCut2.data, cmap=cMap,norm=norm,vmin=vRange[0],vmax=vRange[1],
        interpolation=interpolation)
    if isinstance(imLevels,np.ndarray) and kind=='mom0' and inMom0 is None:
        cs = ax2.contour(hduImCut2.data,levels=imLevels[1,:], colors=imContColors[0],lw=0.4)
    elif isinstance(imLevels,np.ndarray) and inMom0 is not None:

        hduMom0 = fits.open(inMom0[1])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0,mode='partial')
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax2.contour(hduMom0Cut.data,levels=imLevels[1,:], colors=imContColors[0],lw=0.4)
    ax2.coords[0].set_ticks(spacing=c.ra.degree*u.degree)
    ax2.coords[1].set_ticks(spacing=c.dec.degree*u.degree)
    ax2.coords[1].set_axislabel(r'Dec (J2000)')
    ax2.coords[1].set_ticklabel_visible(False)
    ax2.coords[0].set_axislabel(r'RA (J2000)')
      


    if title==True:
        ax2.set_title(cfg_par['moments']['title'][1])

    ax2.set_autoscale_on(False)    
 
    modName = cfg_par['gFit']['modName'] 

    if beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        if 'BMAJ' in hduIm2.header:
            ellX = hduIm2.header['BMAJ']
            ellY = hduIm2.header['BMIN']
            ellPA = hduIm2.header['BPA']
        else:
            ellX = cfg_par['general']['psf'][0]/3600.
            ellY = cfg_par['general']['psf'][1]/3600.
            ellPA = cfg_par['general']['psf'][2]

        el = Ellipse((xbeam, ybeam), ellX, ellY,
                 angle=ellPA, linewidth=1, fill=False, zorder=2,transform=ax2.get_transform('fk5'))
        ax2.add_patch(el)  


 
    if contName:

      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut2.wcs, shape_out=hduImCut2.shape)

        cs = ax2.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax2.clabel(cs, inline=1, fontsize=14)

    ax3 = fig.add_subplot(gs[0,2],projection=hduImCut3.wcs)

  
    if kind == 'mom0':
        mom1BarLabel=cfg_par['moments']['cBarLabel']
        if 'colorTickLabels' in cfg_par['moments']:
            colorTickLabels = cfg_par['moments']['colorTickLabels'][0]
        else:
            colorTickLabels = np.linspace(np.nanmin(hduImCut3.data),np.nanmax(hduImCut3.data),8) 


    elif kind=='mom1':
        mom1BarLabel=r'$v_{\rm los}-v_{\rm sys}$ [km s$^{-1}$]'
        colorTickLabels = np.linspace(vRange[0],vRange[1],5)  

    elif kind=='mom2':
        mom1BarLabel=r'$\sigma_{\rm los}$ [km s$^{-1}$]'
        colorTickLabels = np.arange(vRange[0],vRange[1]+50.,50.)  
    elif kind=='electronDensity':
        mom1BarLabel=r'$\log_{10}(n_e)$'
        colorTickLabels = np.linspace(vRange[0],vRange[1],4)  
        print(colorTickLabels)  
    elif kind=='dustExtinction':
        mom1BarLabel=r'$A_{\alpha}$'
        colorTickLabels = np.linspace(vRange[0],vRange[1],4)  
        print(colorTickLabels)        

    img = ax3.imshow(hduImCut3.data,cmap=cMap,norm=norm,vmin=vRange[0],vmax=vRange[1],
        interpolation=interpolation)

    ax3.coords[0].set_ticks(spacing=c.ra.degree*u.degree)
    ax3.coords[1].set_ticks(spacing=c.dec.degree*u.degree)
    ax3.coords[1].set_axislabel(r'Dec (J2000)')
    ax3.coords[1].set_ticklabel_visible(False)
    ax3.coords[0].set_axislabel(r'RA (J2000)')

    if beamCoords is not None:
        xbeam=beamCoords[0]
        ybeam=beamCoords[1]
        if 'BMAJ' in hduIm3.header:
            ellX = hduIm3.header['BMAJ']
            ellY = hduIm3.header['BMIN']
            ellPA = hduIm3.header['BPA']
        else:
            ellX = cfg_par['general']['psf'][0]/3600.
            ellY = cfg_par['general']['psf'][1]/3600.
            ellPA = cfg_par['general']['psf'][2]

        el = Ellipse((xbeam, ybeam), ellX, ellY,
                 angle=ellPA, linewidth=1, fill=False, zorder=2,transform=ax3.get_transform('fk5'))
        ax3.add_patch(el)  

    axins = inset_axes(ax3,
                   width="5%",  # width = 5% of parent_bbox width
                   height="100%",  # height : 50%
                   loc='lower left',
                   bbox_to_anchor=(1.05, 0., 1, 1),
                   bbox_transform=ax3.transAxes,
                   borderpad=0,
                   )

    if kind!='electronDensity' and kind!='dustExtinction':
        imgFake = ax3.imshow(hduImCut3.data, cmap=cMap,vmin=vRange[0],vmax=vRange[1],
            interpolation=interpolation,alpha=0)
    
        cMap=cm.get_cmap(name=cMap)
        cbar = fig.colorbar(imgFake,cax=axins,cmap =cMap,ticks=colorTickLabels,
                  orientation='vertical', format='%d')

        #cbar.ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))

        fmt = ScalarFormatter(useMathText=True)
        fmt.set_powerlimits((0, 0))
        cbar.ax.yaxis.set_major_formatter(fmt)
        cbar.ax.xaxis.set_major_formatter(fmt)

        cbar.update_ticks()
    else:
        cbar = fig.colorbar(img,cax=axins,cmap =cMap,ticks=colorTickLabels,
                orientation='vertical', format='%.3f')
    


    cbar.set_label(mom1BarLabel, rotation=-90, va="bottom")
    cbar.set_alpha(1)
    cbar.draw_all()

    if title==True:
        ax3.set_title(cfg_par['moments']['title'][2])

    ax3.set_autoscale_on(False)    

    if isinstance(imLevels,np.ndarray) and kind=='mom0' and inMom0 is None:
        cs = ax3.contour(hduImCut3.data,levels=imLevels[2,:], colors=imContColors[0],lw=0.4)
        print('out')
    elif isinstance(imLevels,np.ndarray) and inMom0 is not None:
        hduMom0 = fits.open(inMom0[2])[0]
        wcsMom0 = WCS(hduMom0.header)
        hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0,mode='partial')
        dd = np.array(hduMom0Cut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduMom0Cut.data= dd
        cs = ax3.contour(hduMom0Cut.data,levels=imLevels[2,:], colors=imContColors[0],lw=0.4)

    if contName:
      for i in range(0,len(contName)):

        hduCont = fits.open(contName[i])[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut3.wcs, shape_out=hduImCut3.shape)

        cs = ax3.contour(array.data,levels=contValues[i], colors=contColors[i])
        if contValues[i]==1:
            ax3.clabel(cs, inline=1, fontsize=14)

    #fig.subplots_adjust(hspace=0.,wspace=0.)

    if kind!='electronDensity' and kind!='dustExtinction':
        if contName and inMom0:
            outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['title'][0]+'_overContMom0.'+cfg_par['moments']['plotFormat']
        elif contName and not inMom0:
            outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['title'][0]+'_overCont.'+cfg_par['moments']['plotFormat']
        else:
            outFig= cfg_par['general']['plotMomModDir']+kind+'-'+cfg_par['moments']['title'][0]+'.'+cfg_par['moments']['plotFormat']    
    elif kind=='electronDensity':
        if contName and inMom0:
            outFig= cfg_par['general']['bptPlotDir']+'nE'+'_overContMom0.'+cfg_par['moments']['plotFormat']
        elif contName and not inMom0:
            outFig= cfg_par['general']['bptPlotDir']+'nE'+'_overCont.'+cfg_par['moments']['plotFormat']
        else:
            outFig= cfg_par['general']['bptPlotDir']+'nE'+'.'+cfg_par['moments']['plotFormat']        
            #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)
    elif kind=='dustExtinction':
        if contName and inMom0:
            outFig= cfg_par['general']['bptPlotDir']+'AHalpha'+'_overContMom0.'+cfg_par['moments']['plotFormat']
        elif contName and not inMom0:
            outFig= cfg_par['general']['bptPlotDir']+'AHalpha'+'_overCont.'+cfg_par['moments']['plotFormat']
        else:
            outFig= cfg_par['general']['bptPlotDir']+'AHalpha'+'.'+cfg_par['moments']['plotFormat']        

    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'],bbox_inches = "tight", dpi=300,overwrite=True)#,
    print(outFig)
    #plt.show()
    plt.close()

    return outFig

  def mom0AllLines(self,cfg_par,inMom0=None,
    cRange=None,imLevels=None,imContColors=['black','black','black'],beamCoords=None,
    contName=None,contValues=None,contColors=None,interpolation=None,title=False,
    shareScale=True,kind='mom0'):
    '''Draws all moment maps from a list given in the file cfg_par['general']['lineListName'].

    Parameters
    ----------

    cfg_par: OrderedDictionary
        Dictionary with alla parameters or gufo. 
        Parameters are given from terminal, or in a `.yml' file.

    inMom0: str, optional
        _default=None_, alternative moment map for overplotting contours 
        (for example mom0 contours over mom1 map)

    cRange: np.array, optional
        [2,2] array with the min max range of the two colorscales

    imLevels: np.array, optional
        [2,N] array with N contours to plot (referring to im1, im2 or imMom0, if given)

    imContColors: list, optional
        _default=['black','black','black']_ color of contours

    beamCoords: np.array, optional
        [2,2] array. If given the PSF of the observations is plotted at the coordinates.
        PSF axes and PA are taken from the header of the moments or from cfg_par['genaral']['psf']
    
    contName: str, optional
        full path to continuum image for which overlay the contours

    contValues: np.array, optional
        [N] array with N contours of the continuum image to overlay

    contColors: list, optional
        list with colors of continuum contours

    interpolation: str, optional
        kind of interpolation for `matplotlib.imshow`

    title: list, optional
        2Nlist with title of subplots

    shareScale: bool, optional
        _default=True_: moment maps are plotted over the same colorScale

    kind: str
        _default='mom1'_: kind of moment to plot (mom0, mom1, mom2)

    Returns
    ----------
    outFig: str
        full path to output figure

    Notes
    ----------
    Useful for plotting all total flux distribution maps of the fitted emission lines from an optical observation

    '''


    lineInfo = tP.openLineList(cfg_par)
    lineNameStr =[]
    for ii in range(0,len(lineInfo['ID'])):

        lineNameTmp = str(lineInfo['Name'][ii])

        if '[' in lineNameTmp:
            lineName = lineNameTmp.replace("[", "")
            lineName = lineName.replace("]", "")
            lineName = lineName+str(int(lineInfo['Wave'][ii]))
        else:
            lineName = lineNameTmp+str(int(lineInfo['Wave'][ii]))
        lineNameStr.append(lineName)

    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
    params = ut.loadRcParams()
    plt.rcParams.update(params)
    
    n_plots = len(lineInfo['Wave'])
    n_rows = int(np.ceil(n_plots/3.))

    if not isinstance(cRange,np.ndarray):

        vRange=np.array([1,2])
        vRange[0] = np.nanmin(hduImCut.data)
        vRange[1] = np.nanmax(hduImCut.data)
    else:
        vRange=cRange

    fig = plt.figure(figsize=(12, 12), constrained_layout=False)
    fig.set_tight_layout(False)
    fig.subplots_adjust(hspace=0.,wspace=0.)

    gs_base = plt.GridSpec(nrows=n_rows, ncols=4,  figure=fig,height_ratios=[1,1,1], width_ratios=[1,1,1,0.08])
    gs_base.update(hspace=0.,wspace=0.)


    c = SkyCoord('00:00:02.0','00:00:20.0',unit=(u.hourangle,u.deg))

    cMap = cfg_par['moments']['colorMap'][0]


    im0=cfg_par['general']['momDir']+cfg_par['gFit']['modName']+'/mom0_tot-'+lineNameStr[0]+'.fits'
    hduIm = fits.open(im0)[0]
    wcsIm = WCS(hduIm.header)
    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)

    k=0

    for i in range(0,len(lineInfo['Wave'])):

        if i == 0:
            j = 0
        elif i % 3 == 0:
            j +=1 
            k =0

        im=cfg_par['general']['momDir']+cfg_par['gFit']['modName']+'/mom0_tot-'+lineNameStr[i]+'.fits'

        hduIm = fits.open(im)[0]
        wcsIm = WCS(hduIm.header)
        hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)

        dd = np.array(hduImCut.data,dtype=float)
        index=np.where(dd==0.)
        dd[index] = np.nan
        hduImCut.data= dd

        if i==0:
            ax = fig.add_subplot(gs_base[j,k],projection=wcsIm)
        else:
            ax = fig.add_subplot(gs_base[j,k],projection=wcsIm,sharex=ax,sharey=ax)

        img = ax.imshow(hduImCut.data, cmap=cMap,vmin=vRange[0],vmax=vRange[1],
            interpolation=interpolation)
        
        if isinstance(imLevels,np.ndarray) and kind=='mom0' and inMom0 is None:
            cs = ax.contour(hduImCut2.data,levels=imLevels[0,:], colors=imContColors[0])
    
        elif isinstance(imLevels,np.ndarray) and inMom0 is not None:
            hduMom0 = fits.open(inMom0)[0]
            wcsMom0 = WCS(hduMom0.header)
            hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0)

            #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
            dd = np.array(hduMom0Cut.data,dtype=float)
            index=np.where(dd==0.)
            dd[index] = np.nan
            hduMom0Cut.data= dd
            #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
            cs = ax.contour(hduMom0Cut.data,levels=imLevels[0,:], colors=imContColors[0],lw=0.4)

        if beamCoords is not None:
            xbeam=beamCoords[0]
            ybeam=beamCoords[1]
            if 'BMAJ' in hduIm.header:
                ellX = hduIm.header['BMAJ']
                ellY = hduIm.header['BMIN']
                ellPA = hduIm.header['BPA']
            else:
                ellX = cfg_par['general']['psf'][0]/3600.
                ellY = cfg_par['general']['psf'][1]/3600.
                ellPA = cfg_par['general']['psf'][2]

            el = Ellipse((xbeam, ybeam), ellX, ellY,
                     angle=ellPA, linewidth=1, fill=False, zorder=2,transform=ax.get_transform('fk5'))
            ax.add_patch(el)  


        ax.coords[1].set_ticklabel_visible(False)   
        ax.coords[0].set_ticklabel_visible(False)    
        
        if k==0:    
            ax.coords[1].set_ticklabel_visible(True)  

            ax.coords[1].set_axislabel(r'Dec (J2000)') 

            ax.coords[1].set_ticks(spacing=c.dec.degree*u.degree)

        else:
            ax.coords[1].set_ticks(spacing=c.dec.degree*u.degree)

            ax.coords[1].set_ticklabel_visible(False)  


        if i >= len(lineInfo['Wave'])-3:                
            ax.coords[0].set_ticklabel_visible(True) 
            ax.coords[0].set_ticks(spacing=c.ra.degree*u.degree)

            ax.coords[0].set_axislabel(r'RA (J2000)') 

        else:
            ax.coords[0].set_ticklabel_visible(False)  
            ax.coords[0].set_ticks(spacing=c.ra.degree*u.degree)


        if str(lineInfo['Name'][i])=='Hb':
            lineNameTitle=r'H$\beta$'
        elif str(lineInfo['Name'][i])=='Ha':
            lineNameTitle=r'H$\alpha$'
        else:
            lineNameTitle=str(lineInfo['Name'][i])

        patches = [ mpatches.Patch(edgecolor=None, facecolor=None, linewidth=0, linestyle=None,
                                   color='black',  label=lineNameTitle+str(int(lineInfo['Wave'][i])))]
        # put those patched as legend-handles into the legend
        legend = ax.legend(handles=patches, loc=2, borderaxespad=0.,frameon=False,
                           handlelength=0,handletextpad=0,fontsize=14)
        k+=1

    mom1BarLabel=cfg_par['moments']['cBarLabel']
    axFake=fig.add_subplot(gs_base[j,2])
    axFake.axis('off')
    lineNameColorMapReference='NII6583'
    im=cfg_par['general']['momDir']+cfg_par['gFit']['modName']+'/mom0_tot-'+lineNameColorMapReference+'.fits'


    hduIm = fits.open(im)[0]
    wcsIm = WCS(hduIm.header)
    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)

    dd = np.array(hduImCut.data,dtype=float)
    index=np.where(dd==0.)
    dd[index] = np.nan
    hduImCut.data= dd

    if 'colorTickLabels' in cfg_par['moments']:
        colorTickLabels = cfg_par['moments']['colorTickLabels'][0]
    else:
        colorTickLabels = np.linspace(np.nanmin(hduImCut.data),np.nanmax(hduImCut.data),8,dtype=float)    

    imgFake = axFake.imshow(hduImCut.data, cmap=cMap,
        interpolation=interpolation,alpha=0)

    axCb = fig.add_subplot(gs_base[:,3]) 

    
    cbar = colorbar.Colorbar(mappable=imgFake, ax = axCb, orientation = 'vertical', ticklocation = 'right',ticks=colorTickLabels,format='%d')
    cbar.set_label(mom1BarLabel, rotation=-90, va="bottom")
    cbar.set_alpha(1)
    cbar.draw_all()

    gs_base.update(hspace=0.,wspace=0.00)
    fig.subplots_adjust(hspace=0.,wspace=0.)

    outFig= cfg_par['general']['plotMomModDir']+'mom0AllLines'+'.'+cfg_par['moments']['plotFormat']    
            #dpi=300,bbox_inches='tight',overwrite=True)
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'],bbox_inches = "tight", dpi=300,transparent=False,overwrite=True)#,

    plt.show()
    plt.close()

  def opticalOverlay(self,cfg_par,optName,imNames,
                  cRange,cMap,imLevels=None,
                  imColors=None,beamCoords= None,titleName=None,plotFormat='png',nanToZero=None,zeroToNan=None,interpMethod=None,
                  cScale='log',linthresh=None,base=2.):
        '''Overlays contours of (typically) one or more moment map over an optical image

        Parameters
        ----------

        cfg_par: OrderedDictionary
            Dictionary with alla parameters or gufo. 
            Parameters are given from terminal, or in a `.yml' file.

        optName: str, 
            _default=None_, full path to optical image 
            (for example mom0 contours over mom1 map)
        
        imNames: str, 
            _default=None_, [M] list full path to images to overlay 
            (for example mom0 contours over mom1 map)

        vRange: np.array, optional
            [2,2] array with the min max range of the optical colorscales

        imLevels: np.array, optional
            [2,N] array with N contours to plot (referring to im1, im2 or imMom0, if given)

        imColors: list, optional
            _default=['black',]_ color of contours

        beamCoords: np.array, optional
            [2,2] array. If given the PSF of the observations is plotted at the coordinates.
            PSF axes and PA are taken from the header of the moments or from cfg_par['genaral']['psf']

        interpolation: str, optional
            kind of interpolation for `matplotlib.imshow`

        titleName: list, optional
            2Nlist with title of subplots

        shareScale: bool, optional
            _default=True_: moment maps are plotted over the same colorScale

        kind: str
            _default='mom1'_: kind of moment to plot (mom0, mom1, mom2)

        Returns
        ----------
        outFig: str
            full path to output figure

        Notes
        ----------
        Useful for plotting all total flux distribution maps of the fitted emission lines from an optical observation

        '''

        params = ut.loadRcParams()
        plt.rcParams.update(params)
        hduIm = fits.open(optName)[0]
        wcsIm = WCS(hduIm.header)
        print(optName)
        if nanToZero is not None:
            index=np.isnan(hduImCut.data)
            hduIm.data[index] = 0.0
            mapName=nanToZero
        elif zeroToNan is not None:
            dd = np.array(hduIm.data,dtype=float)
            index=np.where(dd==0.)
            dd[index] = np.nan
            mapName=zeroToNan
            hduIm.data= dd
        objCoordsRA = cfg_par['moments']['centreRA']
        objCoordsDec = cfg_par['moments']['centreDec']
        centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
        sizeUnit = hduIm.header['CDELT2']*hduIm.header['NAXIS2']*60.
        size = u.Quantity((sizeUnit,sizeUnit), u.arcmin)
        size = u.Quantity((cfg_par['moments']['sizePlotY'],cfg_par['moments']['sizePlotX']), u.arcmin)

        hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)
        fig = plt.figure(constrained_layout=False)
        fig.set_tight_layout(False)

        ax1 = plt.subplot(projection=hduImCut.wcs)    


        divider = make_axes_locatable(ax1)

        current_cmap = cm.get_cmap(cMap)

        if nanToZero is not None or zeroToNan is not None:
            current_cmap.set_bad(color=mapName)
            

        if cScale == 'linear':
            img = ax1.imshow(hduImCut.data, cmap=current_cmap,vmin=cRange[0],vmax=cRange[1],interpolation=interpMethod)
        elif cScale == 'sqrt':
            img = ax1.imshow(hduImCut.data, cmap=current_cmap,vmin=cRange[0],vmax=cRange[1],norm=PowerNorm(gamma=0.5))
        elif cScale == 'log':
            img = ax1.imshow(hduImCut.data, cmap=current_cmap,norm=SymLogNorm(linthresh=linthresh,linscale=1.,
                vmin=cRange[0],vmax=cRange[1],base=base),interpolation=interpMethod)

        if imNames is not None:

            size = u.Quantity((cfg_par['moments']['sizePlotY'],cfg_par['moments']['sizePlotX']), u.arcmin)


            for i in range(0,len(imNames)):
                hduMom0 = fits.open(imNames[i])[0]
                wcsMom0 = WCS(hduMom0.header)
                hduMom0Cut = Cutout2D(hduMom0.data, centre, size, wcs=wcsMom0,mode='partial')
                dd = np.array(hduMom0Cut.data,dtype=float)
                index=np.where(dd==0.)
                dd[index] = np.nan
                hduMom0Cut.data= dd

                array, footprint = reproject_interp((hduMom0Cut.data, hduMom0Cut.wcs) ,
                                                    hduImCut.wcs, shape_out=hduImCut.shape)

                #cs = ax3.contour(array.data,levels=contValues[i], colors=contColors[i])

                cs = ax1.contour(array.data,levels=imLevels[i,:,0], colors=imColors[i])

                if np.sum(imLevels[i,:,1])!=np.nan:
                    print("culo")
                    print(np.nanmin(array.data))
                    cs = ax1.contour(array.data,levels=imLevels[i,:,1], colors=imColors[1],linestyles='dashed')
                if 'BMAJ' in hduMom0.header and beamCoords is not None:
                    xbeam=beamCoords[0]
                    ybeam=beamCoords[1]
                    el = Ellipse((xbeam, ybeam), hduMom0.header['BMAJ'], hduMom0.header['BMIN'],
                             angle=hduMom0.header['BMAJ'], linewidth=2, fill=False, zorder=2,transform=ax1.get_transform('fk5'))
                    el.set_edgecolor(imColors[i])            

                    ax1.add_patch(el)       


        ax1.coords[1].set_axislabel(r'Dec (J2000)')
        ax1.coords[0].set_axislabel(r'RA (J2000)')
     

        # if titleName is not None:
        #     ax1.set_title(titleName)



        #SaveOutput

        ax1.set_autoscale_on(False)    
        plotFormat= cfg_par['moments']['plotFormat']
        outFigName= cfg_par['general']['plotMomModDir']+'/'+titleName+'.'+plotFormat

        fig.savefig(outFigName,format=plotFormat, bbox_inches = "tight",overwrite=True,dpi=300,transparent=False)#,
                    #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)

        return 0

  def resPlot(self,cfg_par,imageName,lineName,lineThresh,
    vRange=None,contourColors='black',nameFigLabel=None,overlayContours=False,
    contName=None,contLevels=None,contColors=None):

    objCoordsRA = cfg_par['moments']['centreRA']
    objCoordsDec = cfg_par['moments']['centreDec']
    
    centre = SkyCoord(ra=objCoordsRA*u.degree, dec=objCoordsDec*u.degree, frame='fk5')
    size = u.Quantity((cfg_par['moments']['sizePlots'],cfg_par['moments']['sizePlots']), u.arcmin)
  
    params = self.loadRcParams()
    plt.rcParams.update(params)


    hduIm = fits.open(imageName)[0]
    wcsIm = WCS(hduIm.header)

    hduImCut = Cutout2D(hduIm.data, centre, size, wcs=wcsIm)

    if contName: 
        hduCont = fits.open(contName)[0]
        idx = np.isnan(hduCont.data)
        hduImCut.data[idx] = np.nan
    
    fig = plt.figure()
    
    ax1 = plt.subplot(projection=wcsIm)    

    divider = make_axes_locatable(ax1)
    cax = divider.append_axes("right", size='2%', pad=0.1)
    
    if vRange == None:
      vRange=np.array([1,2])
      vRange[0] = lineThresh
      vRange[1] = np.nanmax(hduImCut.data)
    
    #normalizeData
    normalized = (hduImCut.data-np.nanmin(hduImCut.data))/(np.nanmax(hduImCut.data)-np.nanmin(hduImCut.data))
    img = ax1.imshow(normalized, cmap=cfg_par['moments']['colorMap'][0])#,,vmin=-0.001,vmax=1.001

    colorTickLabels = np.linspace(vRange[0],vRange[1],9.)    

    ax1.coords[1].set_axislabel(r'Dec (J2000)')
    ax1.coords[0].set_axislabel(r'RA (J2000)')
    
    cax.coords[0].grid(False)
    cax.coords[1].grid(False)
    cax.tick_params(direction='in')
    cax.coords[0].tick_params(top=False, bottom=False,
                   labeltop=False, labelbottom=False)
    cax.coords[1].set_ticklabel_position('r')
    cax.coords[1].set_axislabel(cfg_par['moments']['cBarLabel'][0])
    cax.coords[1].set_axislabel_position('r')
    cbar = plt.colorbar(img, cax=cax,ticks =colorTickLabels,
                    orientation='vertical', format='%d')   
    
    ax1.set_title(lineName)

    ax1.set_autoscale_on(False)    
    #SaveOutput
    outMom = os.path.basename(imageName)
    outMom= str.split(outMom, '.fits')[0]  
    modName = cfg_par['gFit']['modName'] 

    if nameFigLabel==None:
        nameFigLabel='' 
    
    if overlayContours:
        #contLevels = np.linspace(lineThresh*1.2,np.nanmax(hduImCut.data)*0.95,step)
        nameFigLabel = nameFigLabel+'_cs'
        hduCont = fits.open(contName)[0]
        wcsCont = WCS(hduCont.header)
        hduContCut = Cutout2D(hduCont.data, centre, size, wcs=wcsCont)    
        array, footprint = reproject_interp((hduContCut.data, hduContCut.wcs) ,
                                            hduImCut.wcs, shape_out=hduImCut.shape)
        if contLevels==None:
          contLevels = lineThresh*1.2*(np.arange(1,10,2))

        ax1.contour(array.data,levels=contLevels, colors=contColors)
      

    outFig = cfg_par['general']['momDir']+outMom+nameFigLabel+'.'+cfg_par['moments']['plotFormat']
    fig.savefig(outFig,format=cfg_par['moments']['plotFormat'], bbox_inches = "tight",overwrite=True,dpi=100)#,
            #dpi=300,bbox_inches='tight',transparent=False,overwrite=True)



    return 0


